//
// Created by Great Drake on 1/9/21.
//

#ifndef ITERATORS_HPP
#define ITERATORS_HPP

#include <memory>

//template<class T >
//class ListBidirectionalIterator: public std::iterator< std::bidirectional_iterator_tag, T>
//{
//    template <class, class Alloc>
//    friend class list;
//
//private:
//    ListBidirectionalIterator(T* p) : _p(p) { };
//public:
//    ListBidirectionalIterator(const ListBidirectionalIterator &it) : _p(it._p) { };
//
//    bool operator!=(ListBidirectionalIterator const& other) const { return _p != other._p; };
//    bool operator==(ListBidirectionalIterator const& other) const { return _p == other._p; };
//    typename ListBidirectionalIterator::reference operator*() const {
//        return *_p;
//    };
//    ListBidirectionalIterator& operator++() { ++_p; return *this;}
//private:
//    T* _p;
//};


//template<class T >
//class OwnReverseInputIterator: public std::reverse_iterator< OwnInputIterator<T> >
//{
//    template <class, class Alloc>
//    friend class list;
//
//private:
//    OwnReverseInputIterator(T* p) : std::reverse_iterator< OwnInputIterator(p) >()  { };
//public:
////    OwnReverseInputIterator(const OwnReverseInputIterator &it) : _p(it._p) { };
//
////    bool operator!=(OwnReverseInputIterator const& other) const { return _p != other._p; };
////    bool operator==(OwnReverseInputIterator const& other) const { return _p == other._p; };
////    typename OwnInputIterator::reference operator*() const {
////        return *_p;
////    };
////    OwnInputIterator& operator++() { ++_p; return *this;}
////private:
////    T* _p;
//};
//
#endif //UNTITLED_ITERATORS_HPP













